# -*- coding: utf-8 -*-
"""project_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NM_A5s171gKJO6-sQYHd2D0XDCGY_tDX
"""

import numpy as np
import pandas as pd
#import seaborn as sns
#import matplotlib.pyplot as plt
import collections
from collections import Counter

#Загрузка файла в Google Colab
from google.colab import files
uploaded = files.upload()

#Чтение файла
data = pd.read_csv('movie_bd_v5.xls')

data.describe()

"""# Предобработка"""

answers = {} # создадим словарь для ответов

# тут другие ваши предобработки колонок например:

#the time given in the dataset is in string format.
#So we need to change this in datetime format
# ...

#Удаление ненужного столбца. 
data.drop(['tagline'], axis = 1, inplace=True)
#Форматирование даты выхода. 
data['release_date'] = pd.to_datetime(data['release_date'])
#Добавление столбцов Профит и Месяц. 
data['profit'] = data['revenue'] - data['budget']
data['month'] = data['release_date'].dt.month
#Проверка
data.head()

"""# 1. У какого фильма из списка самый большой бюджет?

Использовать варианты ответов в коде решения запрещено.    
Вы думаете и в жизни у вас будут варианты ответов?)
"""

# в словарь вставляем номер вопроса и ваш ответ на него
# Пример: 
#answers['1'] = '2. Spider-Man 3 (tt0413300)'
# запишите свой вариант ответа
#answers['1'] = '...'
# если ответили верно, можете добавить комментарий со значком "+"

data[data.budget == data.budget.max()]
# тут пишем ваш код для решения данного вопроса:
#+

"""ВАРИАНТ 2"""

# Более простого варианта не нашел.

"""# 2. Какой из фильмов самый длительный (в минутах)?"""

# думаю логику работы с этим словарем вы уже поняли, 
# по этому не буду больше его дублировать
#answers['2'] = '...'

data[data.runtime == data.runtime.max()]

"""# 3. Какой из фильмов самый короткий (в минутах)?"""

data[data.runtime == data.runtime.min()]

"""# 4. Какова средняя длительность фильмов?"""

data.runtime.mean()

"""# 5. Каково медианное значение длительности фильмов?"""

data.runtime.median()

"""# 6. Какой самый прибыльный фильм?
#### Внимание! Здесь и далее под «прибылью» или «убытками» понимается разность между сборами и бюджетом фильма. (прибыль = сборы - бюджет) в нашем датасете это будет (profit = revenue - budget)
"""

# лучше код получения столбца profit вынести в Предобработку что в начале
data[data.profit == data.profit.max()]

"""# 7. Какой фильм самый убыточный?"""

data[data.profit == data.profit.min()]

"""# 8. У скольких фильмов из датасета объем сборов оказался выше бюджета?"""

len(data[data.profit > 0])

"""# 9. Какой фильм оказался самым кассовым в 2008 году?"""

#Фильтрую по году
year_2008 = data[data.release_year == 2008]
year_2008[year_2008.profit == year_2008.profit.max()]

"""# 10. Самый убыточный фильм за период с 2012 по 2014 г. (включительно)?"""

#Фильтрую по периоду
period = data[(data.release_year > 2012) & (data.release_year <= 2014)]
period[period.profit == period.profit.min()]

"""# 11. Какого жанра фильмов больше всего?"""

# эту задачу тоже можно решать разными подходами, попробуй реализовать разные варианты
# если будешь добавлять функцию - выноси ее в предобработку что в начале
pd.Series(data['genres'].str.cat(sep='|').split('|')).value_counts()

"""ВАРИАНТ 2"""

#Подсчет через collections.Counter
genre_list = data['genres'].str.cat(sep='|').split(sep='|')
c = collections.Counter()
for category in genre_list:
    c[category] += 1
print(c)

"""# 12. Фильмы какого жанра чаще всего становятся прибыльными?"""

#Фильтрую по прибыли
profit_df = data[data.profit>0]
pd.Series(profit_df['genres'].str.cat(sep='|').split('|')).value_counts()

"""# 13. У какого режиссера самые большие суммарные кассовые сбооры?"""

#Создаю новый, чтоб не портить исходный
data_dir = data.copy()
#Избавляюсь от разделителей
data_dir['dir_list'] = data_dir['director'].str.split('|')
data_dir_list = data_dir.explode('dir_list')
#Подсчет через groupby 
data_dir_list.groupby(['dir_list'])['revenue'].sum().sort_values(ascending=False)

"""# 14. Какой режисер снял больше всего фильмов в стиле Action?"""

action_dir_list = data[data['genres'].str.contains('Action')]
Counter(action_dir_list.director.str.cat(sep='|').split('|')).most_common(1)

"""# 15. Фильмы с каким актером принесли самые высокие кассовые сборы в 2012 году?"""

#Создаю новый, чтоб не портить исходный
data2012 = data[data['release_year'] == 2012].copy()
#Избавляюсь от разделителей
data2012['cast_list'] = data2012['cast'].str.split('|')
data_cast_list = data2012.explode('cast_list')
#Подсчет через groupby
data_cast_list.groupby(['cast_list'])['revenue'].sum().sort_values(ascending=False)

"""# 16. Какой актер снялся в большем количестве высокобюджетных фильмов?"""

#Фильтрую по бюджету
data_high = data[data.budget > data.budget.mean()]
#Вычисление через collections.Counter
Counter(data_high.cast.str.cat(sep='|').split('|')).most_common(1)

"""# 17. В фильмах какого жанра больше всего снимался Nicolas Cage?"""

#Фильтрую по актеру
data_cage = data[data.cast.str.contains('Nicolas Cage')]
#Вычисление через collections.Counter
Counter(data_cage.genres.str.cat(sep='|').split('|')).most_common(1)

"""# 18. Самый убыточный фильм от Paramount Pictures"""

#Фильтрую по студии
data_parpict = data[data.production_companies.str.contains('Paramount Pictures')]
data_parpict[data_parpict.profit == data_parpict.profit.min()]

"""# 19. Какой год стал самым успешным по суммарным кассовым сборам?"""

data.groupby(['release_year'])['revenue'].sum().sort_values(ascending=False)

"""# 20. Какой самый прибыльный год для студии Warner Bros?"""

#Фильтрую по студии
data_warner = data[data.production_companies.str.contains('Warner Bros')]
data_warner.groupby(['release_year'])['revenue'].sum().sort_values(ascending=False)

"""# 21. В каком месяце за все годы суммарно вышло больше всего фильмов?"""

data.month.value_counts()

"""# 22. Сколько суммарно вышло фильмов летом? (за июнь, июль, август)"""

data.month[(data.month == 6) | (data.month == 7) | (data.month == 8)].count()

"""# 23. Для какого режиссера зима – самое продуктивное время года?"""

data_winter = data[(data.month == 1) | (data.month == 2) | (data.month == 12)]
Counter(data_winter.director.str.cat(sep='|').split('|')).most_common(1)

"""# 24. Какая студия дает самые длинные названия своим фильмам по количеству символов?"""

#Создаю новый, чтоб не портить исходный
data_title = data.copy()
#Вычисляю длину названия
data_title['title_length'] = data_title.original_title.apply(lambda x: len(x))
#Избавляюсь от разделителей
data_title['comp_list'] = data_title['production_companies'].str.split('|')
data_title_list = data_title.explode('comp_list')
#Подсчет
data_title_list.groupby(['comp_list'])['title_length'].mean().sort_values(ascending=False)

"""# 25. Описание фильмов какой студии в среднем самые длинные по количеству слов?"""

#Создаю новый, чтоб не портить исходный
data_overview = data.copy()
#Вычисляю длину описаний 
data_overview['over_length'] = data_overview.overview.apply(lambda x: len(x.split(' ')))
#Избавляюсь от разделителей
data_overview['comp_list'] = data_overview['production_companies'].str.split('|')
data_over_list = data_overview.explode('comp_list')
#Подсчет
data_over_list.groupby(['comp_list'])['over_length'].mean().sort_values(ascending=False)

"""# 26. Какие фильмы входят в 1 процент лучших по рейтингу? 
по vote_average
"""

#Подсчет через квантиль 
data[data.vote_average > np.quantile(data.vote_average, .99)]['original_title']

"""# 27. Какие актеры чаще всего снимаются в одном фильме вместе?"""

#Цикл для создания пар.
pairs=[]
for i in range(len(data)):
    cast_new=data.loc[i,'cast'].split('|')
    for j in range(len(cast_new)-1):
        for k in range(j+1,len(cast_new)):
            pairs.append(sorted([cast_new[j],cast_new[k]]))
#Не выношу функцию в предобратотку, так как она используется только тут.
#Функция подсчета самых встречающихся значений
def most_frequent(pairs):
    counter = 0
    num = pairs[0]
    for i in pairs:
      curr_frequency = pairs.count(i)
      if(curr_frequency > counter):
        counter = curr_frequency
        num = i
    return num
print(most_frequent(pairs))

"""Была еще попытка решить через itertools.combinations"""

import itertools
#Создание упрощенного датафрейма
data_pairs = data[['cast','original_title']].copy()
#Избавление от разделителей
data_pairs['cast_list'] = data_pairs['cast'].str.split('|')
#Сортировка данных
data_pairs.sort_values('cast_list')
#Добавление пар в датафрейм
data_pairs['pair_list'] = data_pairs.cast_list.apply(lambda row: itertools.combinations(row, 2))
data_pairs
#А вот дальше не понял, как обработать, увы...

"""# Submission"""

#Вынес все ответы сюда, так удобнее. 
answers['01'] = '5. Pirates of the Caribbean: On Stranger Tides (tt1298650)' #+
answers['02'] = '2. Gods and Generals (tt0279111)' #+
answers['03'] = '3. Winnie the Pooh (tt1449283)' #+
answers['04'] = '2. 110' #+
answers['05'] = '1. 107.0' #+
answers['06'] = '5. Avatar (tt0499549)' #+
answers['07'] = '5. The Lone Ranger (tt1210819)' #+
answers['08'] = '1. 1478' #+
answers['09'] = '4. The Dark Knight (tt0468569)' #+
answers['10'] = '5. The Lone Ranger (tt1210819)' #+
answers['11'] = '3. Drama' #+
answers['12'] = '1. Drama' #+
answers['13'] = '5. Peter Jackson' #+
answers['14'] = '3. Robert Rodriguez' #+
answers['15'] = '3. Chris Hemsworth' #+
answers['16'] = '3. Matt Damon' #+
answers['17'] = '2. Action' #+
answers['18'] = '1. K-19: The Widowmaker (tt0267626)' #+
answers['19'] = '5. 2015 (25449202382)' #+
answers['20'] = '1. 2014 (3243064519)' #+
answers['21'] = '4. Сентябрь (227)' #+
answers['22'] = '2. 450' #+
answers['23'] = '5. Peter Jackson (7)' #+
answers['24'] = '5. Four By Two Productions' #+
answers['25'] = '3. Midnight Picture Show' #+
answers['26'] = '1. Inside Out, The Dark Knight, 12 Years a Slave' #+
answers['27'] = '5. Daniel Radcliffe & Rupert Grint' #+

# в конце можно посмотреть свои ответы к каждому вопросу
answers

# и убедиться что ни чего не пропустил)
len(answers)